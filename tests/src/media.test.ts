import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { PocketIc, type Actor } from "@dfinity/pic";
import { Principal } from "@dfinity/principal";
import { readFileSync } from "fs";
import { resolve } from "path";

// Import the canister interface (this will be generated by dfx)
// For now, we'll define the interface inline
interface MediaService {
  uploadMedia: (
    fileName: string,
    contentType: string,
    mediaType: any,
    fileData: Uint8Array,
  ) => Promise<any>;
  getMediaItem: (mediaId: string) => Promise<any>;
  getMediaByOwner: (ownerId: Principal) => Promise<any[]>;
  getMediaByTypeAndOwner: (
    ownerId: Principal,
    mediaType: any,
  ) => Promise<any[]>;
  deleteMedia: (mediaId: string) => Promise<any>;
  updateMediaMetadata: (mediaId: string, fileName?: string) => Promise<any>;
  getStorageStats: () => Promise<any>;
}

describe("Media Canister", () => {
  let pic: PocketIc;
  let actor: Actor<MediaService>;
  let userPrincipal: Principal;

  beforeEach(async () => {
    pic = await PocketIc.create(process.env["PIC_URL"] || "");

    // Create a test user principal
    userPrincipal = Principal.fromText("rdmx6-jaaaa-aaaah-qcaiq-cai");

    // Read the canister wasm file
    const wasmPath = resolve(
      __dirname,
      "../../.dfx/local/canisters/media/media.wasm",
    );
    const wasmBuffer = readFileSync(wasmPath);
    const wasm = wasmBuffer.buffer.slice(
      wasmBuffer.byteOffset,
      wasmBuffer.byteOffset + wasmBuffer.byteLength,
    );

    // Install the canister
    const fixture = await pic.setupCanister<MediaService>({
      idlFactory: ({ IDL }) => {
        const MediaType = IDL.Variant({
          UserProfile: IDL.Null,
          ServiceImage: IDL.Null,
        });
        const MediaItem = IDL.Record({
          id: IDL.Text,
          url: IDL.Text,
          thumbnailUrl: IDL.Opt(IDL.Text),
          ownerId: IDL.Principal,
          createdAt: IDL.Int,
          fileName: IDL.Text,
          updatedAt: IDL.Int,
          mediaType: MediaType,
          fileSize: IDL.Nat,
          filePath: IDL.Text,
          contentType: IDL.Text,
        });
        const Result = IDL.Variant({ ok: MediaItem, err: IDL.Text });
        const Result_1 = IDL.Variant({ ok: IDL.Text, err: IDL.Text });
        const Result_2 = IDL.Variant({ ok: MediaItem, err: IDL.Text });
        const Stats = IDL.Record({
          totalItems: IDL.Nat,
          totalSize: IDL.Nat,
          userCount: IDL.Nat,
          typeBreakdown: IDL.Vec(IDL.Tuple(MediaType, IDL.Nat)),
        });
        return IDL.Service({
          deleteMedia: IDL.Func([IDL.Text], [Result_1], []),
          getMediaByOwner: IDL.Func(
            [IDL.Principal],
            [IDL.Vec(MediaItem)],
            ["query"],
          ),
          getMediaByTypeAndOwner: IDL.Func(
            [IDL.Principal, MediaType],
            [IDL.Vec(MediaItem)],
            ["query"],
          ),
          getMediaItem: IDL.Func([IDL.Text], [Result_2], ["query"]),
          getStorageStats: IDL.Func([], [Stats], ["query"]),
          updateMediaMetadata: IDL.Func(
            [IDL.Text, IDL.Opt(IDL.Text)],
            [Result],
            [],
          ),
          uploadMedia: IDL.Func(
            [IDL.Text, IDL.Text, MediaType, IDL.Vec(IDL.Nat8)],
            [Result],
            [],
          ),
        });
      },
      wasm,
      sender: userPrincipal,
    });

    actor = fixture.actor;
  });

  afterEach(async () => {
    await pic.tearDown();
  });

  describe("uploadMedia", () => {
    it("should successfully upload a valid image file", async () => {
      // Setup
      const fileName = "test-image.jpg";
      const contentType = "image/jpeg";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array([255, 216, 255, 224]); // JPEG header bytes

      // Execute
      const result = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );

      // Assert
      expect(result).toHaveProperty("ok");
      if ("ok" in result) {
        const mediaItem = result.ok;
        expect(mediaItem.fileName).toBe(fileName);
        expect(mediaItem.contentType).toBe(contentType);
        expect(mediaItem.mediaType).toEqual(mediaType);
        expect(mediaItem.fileSize).toBe(fileData.length);
        expect(mediaItem.ownerId.toString()).toBe(userPrincipal.toString());
        expect(mediaItem.url).toContain("users");
        expect(mediaItem.filePath).toContain("users");
      }
    });

    it("should reject file that exceeds size limit", async () => {
      // Setup
      const fileName = "large-file.jpg";
      const contentType = "image/jpeg";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array(500_000); // 500KB - exceeds 450KB limit

      // Execute
      const result = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toContain("File size must be between");
      }
    });

    it("should reject unsupported file type", async () => {
      // Setup
      const fileName = "test-file.txt";
      const contentType = "text/plain";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"

      // Execute
      const result = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toContain("Unsupported file type");
      }
    });

    it("should reject empty file name", async () => {
      // Setup
      const fileName = "";
      const contentType = "image/png";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array([137, 80, 78, 71]); // PNG header

      // Execute
      const result = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toContain("File name must be between");
      }
    });

    it("should reject zero-size file", async () => {
      // Setup
      const fileName = "empty.jpg";
      const contentType = "image/jpeg";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array(0);

      // Execute
      const result = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toContain("File size must be between");
      }
    });
  });

  describe("getMediaItem", () => {
    it("should retrieve uploaded media item by ID", async () => {
      // Setup - upload a file first
      const fileName = "test-retrieve.png";
      const contentType = "image/png";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);

      const uploadResult = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );
      expect(uploadResult).toHaveProperty("ok");

      if ("err" in uploadResult) {
        throw new Error("Upload failed");
      }

      const mediaId = uploadResult.ok.id;

      // Execute
      const result = await actor.getMediaItem(mediaId);

      // Assert
      expect(result).toHaveProperty("ok");
      if ("ok" in result) {
        const mediaItem = result.ok;
        expect(mediaItem.id).toBe(mediaId);
        expect(mediaItem.fileName).toBe(fileName);
      }
    });

    it("should return error for non-existent media ID", async () => {
      // Setup
      const nonExistentId = "non-existent-123";

      // Execute
      const result = await actor.getMediaItem(nonExistentId);

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toBe("Media item not found");
      }
    });
  });

  describe("getMediaByOwner", () => {
    it("should return all media items for a user", async () => {
      // Setup - upload multiple files
      const uploads = [
        {
          fileName: "profile1.jpg",
          contentType: "image/jpeg",
          mediaType: { UserProfile: null },
          fileData: new Uint8Array([255, 216, 255, 224]),
        },
        {
          fileName: "profile2.png",
          contentType: "image/png",
          mediaType: { UserProfile: null },
          fileData: new Uint8Array([137, 80, 78, 71]),
        },
      ];

      for (const upload of uploads) {
        const result = await actor.uploadMedia(
          upload.fileName,
          upload.contentType,
          upload.mediaType,
          upload.fileData,
        );
        expect(result).toHaveProperty("ok");
      }

      // Execute
      const result = await actor.getMediaByOwner(userPrincipal);

      // Assert
      expect(result).toHaveLength(2);
      expect(result.map((item: any) => item.fileName)).toEqual(
        expect.arrayContaining(["profile1.jpg", "profile2.png"]),
      );
    });

    it("should return empty array for user with no media", async () => {
      // Setup
      const anotherUser = Principal.fromText("rrkah-fqaaa-aaaah-qcaiq-cai");

      // Execute
      const result = await actor.getMediaByOwner(anotherUser);

      // Assert
      expect(result).toHaveLength(0);
    });
  });

  describe("deleteMedia", () => {
    it("should successfully delete owned media item", async () => {
      // Setup - upload a file first
      const fileName = "to-delete.jpg";
      const contentType = "image/jpeg";
      const mediaType = { UserProfile: null };
      const fileData = new Uint8Array([255, 216, 255, 224]);

      const uploadResult = await actor.uploadMedia(
        fileName,
        contentType,
        mediaType,
        fileData,
      );
      expect(uploadResult).toHaveProperty("ok");

      if ("err" in uploadResult) {
        throw new Error("Upload failed");
      }

      const mediaId = uploadResult.ok.id;

      // Execute
      const deleteResult = await actor.deleteMedia(mediaId);

      // Assert
      expect(deleteResult).toHaveProperty("ok");
      if ("ok" in deleteResult) {
        expect(deleteResult.ok).toBe("Media item deleted successfully");
      }

      // Verify it's actually deleted
      const getResult = await actor.getMediaItem(mediaId);
      expect(getResult).toHaveProperty("err");
    });

    it("should return error when deleting non-existent media", async () => {
      // Setup
      const nonExistentId = "non-existent-456";

      // Execute
      const result = await actor.deleteMedia(nonExistentId);

      // Assert
      expect(result).toHaveProperty("err");
      if ("err" in result) {
        expect(result.err).toBe("Media item not found");
      }
    });
  });

  describe("getStorageStats", () => {
    it("should return correct storage statistics", async () => {
      // Setup - upload a few files
      const uploads = [
        {
          fileName: "stat1.jpg",
          contentType: "image/jpeg",
          mediaType: { UserProfile: null },
          fileData: new Uint8Array(1000),
        },
        {
          fileName: "stat2.png",
          contentType: "image/png",
          mediaType: { ServiceImage: null },
          fileData: new Uint8Array(2000),
        },
      ];

      for (const upload of uploads) {
        await actor.uploadMedia(
          upload.fileName,
          upload.contentType,
          upload.mediaType,
          upload.fileData,
        );
      }

      // Execute
      const result = await actor.getStorageStats();

      // Assert
      expect(result.totalItems).toBe(2);
      expect(result.totalSize).toBe(3000);
      expect(result.userCount).toBe(1);
      expect(result.typeBreakdown).toEqual(
        expect.arrayContaining([
          [{ UserProfile: null }, 1],
          [{ ServiceImage: null }, 1],
        ]),
      );
    });
  });
});
